###############################################################################
#
#     Snakefile - Allele specific expression using ASElux
#
#
###############################################################################


shell.prefix("set -eo pipefail; echo BEGIN at $(date); ")
shell.suffix("; exitstat=$?; echo END at $(date); echo exit status was $exitstat; exit $exitstat")

import numpy
import pandas as pd
import os

configfile: "config.yaml"

sample_file = config['sample_list']
sample_df = pd.read_table(sample_file, sep="\t+", header=0)
sampleID = sample_df.sampleID
fastq = sample_df.fastq

# ----------  SET VARIABLES  ----------

SCRATCH = config["SCRATCH"]
REF_GENOME = config["REF_GENOME"]
GENE_ANNOT = config["GENE_ANNOT"]
READ_LENGTH = config["READ_LENGTH"]

FILES = json.load(open(config['SAMPLES_JSON']))
MERGE_FILES = json.load(open(config['MERGE_FILES_JSON']))
print()
ALL_SAMPLES = sorted(MERGE_FILES.keys())
ALL_MERGED_SAMPLES = sorted(MERGE_FILES.keys()) 
print(ALL_MERGED_SAMPLES)
FASTQs, = glob_wildcards(SCRATCH + "/fastqs/{smp}.fastq")


# -------------  RULES  --------------

localrules: move_and_rename_fastqs

rule all:
    input:   
#             expand(SCRATCH + "/01RAW_fqs/{sample}", sample = sample_df.sampleID),
#             expand(SCRATCH + "/02ZIPPED_fqs/{sample}", sample = sample_df.sampleID),
#             expand(SCRATCH + "/03MRGD_fqs/{sampleID}_R2.fastq.gz", sampleID = ALL_MERGED_SAMPLES),
             expand(SCRATCH + "/04TRIM_fqs/{sampleID}_val_2.fq.gz", sampleID = ALL_MERGED_SAMPLES),
             expand(SCRATCH + "/01fqc/trimmed_mrg/{sampleID}_val_2_fastqc.zip", sampleID = ALL_MERGED_SAMPLES),

#             expand(SCRATCH + "/01fqc/pre-trimmed/{smp}_fastqc.zip", smp = FASTQs),
#             SCRATCH + "/02multiQC/multiQC_log.html",
#             expand(SCRATCH + "/01fqc/trimmed/{sample}_val_2_fastqc.zip", sample = ALL_SAMPLES),
#             SCRATCH + "/05static_index/ASElux_static_index.annotation",
#             expand(SCRATCH + "/05vcfs/{sample}.chr.vcf", sample = ALL_SAMPLES),
             expand(SCRATCH + "/07HARDTRIM_fqs/{sampleID}_val_2.noSR.fq.gz", sampleID = ALL_MERGED_SAMPLES),
#             expand(SCRATCH + "/07read_distribution/trimmed/{sample}_R2_readDist.txt",sample = ALL_SAMPLES),
             expand(SCRATCH + "/08READ_DIST/hrd_trm/{sampleID}_R2_readDist.txt", sampleID = ALL_MERGED_SAMPLES),
             expand(SCRATCH + "/08READ_DIST/hrd_trm_noSR/{sampleID}_R2_readDist.txt", sampleID = ALL_MERGED_SAMPLES),
             expand(SCRATCH + "/09ASE_MAPPINGS/{sampleID}.ase.txt", sampleID = ALL_MERGED_SAMPLES),

rule move_and_rename_fastqs:
    input:  fastq = lambda w: sample_df[sample_df.sampleID == w.sample].fastq.tolist()
    output: temp(SCRATCH + "/01RAW_fqs/{sample}")
    log:    SCRATCH + "/00logs/01RAW_fqs/{sample}.log"
    shell:
            """cp {input.fastq} {output} 2> {log}"""

rule zip_fastqs:
    input:  SCRATCH + "/01RAW_fqs/{sample}"
    output: temp(SCRATCH + "/02ZIPPED_fqs/{sample}")
    params: outdir = SCRATCH + "/02ZIPPED_fqs/"
    log:    SCRATCH + "/00logs/02ZIPPED_fqs/{sample}.log"
    run:

        if wildcards.sample.endswith('.fastq'):
            shell("""gzip {input} 2> {log}""")
            shell("""mv {input}.gz {params.outdir} 2> {log}""")
            shell("""touch {output}""")
        else:
            shell("""mv {input} {params.outdir} 2> {log}""")
            shell("""touch {output}""") 

rule merge_fastqs:
    input:  r1 = lambda wildcards: MERGE_FILES[wildcards.sampleID]['R1'],
            r2 = lambda wildcards: MERGE_FILES[wildcards.sampleID]['R2']
    output: r1 = temp(SCRATCH + "/03MRGD_fqs/{sampleID}_R1.fastq.gz"),
            r2 = temp(SCRATCH + "/03MRGD_fqs/{sampleID}_R2.fastq.gz")
    log:    r1 = SCRATCH + "/00logs/03MRGD_fqs/{sampleID}_R1.log",
            r2 = SCRATCH + "/00logs/03MRGD_fqs/{sampleID}_R2.log"
    params: indir = SCRATCH + "/02ZIPPED_fqs/", outdir = SCRATCH + "/03MRGD_fqs/"
    run:
            if len(input.r1) > 1:
                print(wildcards.sample, ": has > 1 fastq file per read.\n", {input.r1})
                shell("cat {params.indir}{wildcards.sampleID}*_R1.fastq.gz > {output.r1} 2> {log.r1}"),
                shell("cat {params.indir}{wildcards.sampleID}*_R2.fastq.gz > {output.r2} 2> {log.r2}")

            else:
                print(wildcards.sample, ": has only 1 fastq file per read.\n", {input.r1})
                shell("mv {params.indir}{wildcards.sampleID}*_R1.fastq.gz {params.outdir}{wildcards.sampleID}_R1.fastq.gz 2> {log.r1}"),
                shell("mv {params.indir}{wildcards.sampleID}*_R2.fastq.gz {params.outdir}{wildcards.sampleID}_R2.fastq.gz 2> {log.r2}")           

rule fastqc:
    input:   SCRATCH + "/fastqs/{smp}.fastq" 
    output:  SCRATCH + "/01fqc/pre-trimmed/{smp}_fastqc.zip"
    log:     SCRATCH + "/00log/fqc/{smp}_fastqc"
    params:  outdir = SCRATCH + "/01fqc"
    message: "fastqc {input}"
    shell:
             """
             
             # fastqc works fine on .gz file as well
             module load FastQC
             fastqc -o {params.outdir} -f fastq {input} 2> {log}
        
             """

rule multiQC_pretrim:
    input:   expand(SCRATCH + "/01fqc/{smp}_fastqc.zip", smp=FASTQs)
    output:  SCRATCH + "/02multiQC/multiQC_log.html"
    log:     SCRATCH + "/00log/multiqc.log"
    params:  indir = SCRATCH + "/01fqc", outfile = SCRATCH + "/02multiQC/multiQC_log"
    message: "multiqc for pre-trimmed fastqc"
    shell:
             """
             multiqc {params.indir} -o {output} -d -f -v -n {params.outfile} 2> {log}
        
             """

rule trim_fastq:
    input:   r1 = SCRATCH + "/03MRGD_fqs/{sampleID}_R1.fastq.gz",
             r2 = SCRATCH + "/03MRGD_fqs/{sampleID}_R2.fastq.gz"
    output:  SCRATCH + "/04TRIM_fqs/{sampleID}_val_1.fq.gz",
             SCRATCH + "/04TRIM_fqs/{sampleID}_val_2.fq.gz",
             SCRATCH + "/01fqc/trimmed_mrg/{sampleID}_val_1_fastqc.zip",
             SCRATCH + "/01fqc/trimmed_mrg/{sampleID}_val_2_fastqc.zip"    
    log:     SCRATCH + "/00log/04TRIM_fqs/{sampleID}.log"
    conda:   SCRATCH + "/envs/trim-galore.yaml"
    threads: 4
    params:  outdir_trim = SCRATCH + "/04TRIM_fqs",
             outdir_trim_fqc = SCRATCH + "/01fqc/trimmed_mrg/" 
    message: "Trim Galore: {input}"
    shell:   
             """
             trim_galore -e 0.1 -q 20  --paired --basename {wildcards.sampleID} \
             --illumina --output_dir {params.outdir_trim} -j 4 \
             --fastqc_args "-o {params.outdir_trim_fqc} -f fastq" {input.r1} {input.r2} 2> {log} 
             """

rule build_static_index:
    input:   ref = SCRATCH + "/refs/genome_sequence/" +	REF_GENOME,
             gtf = SCRATCH + "/refs/annotation_files/" + GENE_ANNOT
    output:  SCRATCH + "/05static_index/ASElux_static_index.annotation"
    log:     SCRATCH +  "/00logs/05build_static_index.log"
    params:  outdir = SCRATCH + "/05static_index/ASElux_static_index"
    shell:       
             """
             module load compiler/gnu/5
             ASElux build --gtf {input.gtf} \
             --ref {input.ref} \
             --out {params.outdir} 2> {log} 
             """
 
rule extract_sample_genotypes:
    input:   SCRATCH + "/06vcfs/genotypes.chr.vcf-v4.2"
    output:  SCRATCH + "/06vcfs/{sample}.chr.vcf"
    log:     SCRATCH +  "/06logs/06genotypes/{sample}.log"
    params : jobname = "{sample}"
    message: "Extracting {wildcards.sample} genotype info"
    shell:
             """
             
             bcftools annotate -x INFO,^FORMAT/GT {input} \
             | bcftools view -Ov -s {wildcards.sample} > {output} 2> {log}     
             """

rule hard_trim_fastq:
    input:   r1 = SCRATCH + "/04TRIM_fqs/{sampleID}_val_1.fq.gz", 
             r2 = SCRATCH + "/04TRIM_fqs/{sampleID}_val_2.fq.gz" 
    output:  r1 = temp(SCRATCH + "/07HARDTRIM_fqs/{sampleID}_val_1.fq.gz"),
             r2 = temp(SCRATCH + "/07HARDTRIM_fqs/{sampleID}_val_2.fq.gz")
    log:     SCRATCH + "/00logs/07HARDTRIM_fqs/{sampleID}.log"
    params:  crdf = 54, extr = 79, edin = 104 # Co-ords are 0 based
    message: "\nHard trimming {wildcards.sampleID}\n"
    run:
            if "Crdf" in wildcards.sampleID:
                
                print("\n", wildcards.sampleID, "will be trimmed to a length of 55 reads\n")
                shell("/scratch/c.c1477909/bbmap/bbduk.sh in1={input.r1} in2={input.r2} out1={output.r1} out2={output.r2} ftr={params.crdf} ordered=t 2> {log}")
            
                
            elif "Extr" in wildcards.sampleID:

                print("\n", wildcards.sampleID, "will be trimmed to a length of 80 reads\n")
                shell("/scratch/c.c1477909/bbmap/bbduk.sh in1={input.r1} in2={input.r2} out1={output.r1} out2={output.r2} ftr={params.extr} ordered=t 2> {log}")       
           
            else:
              
                print("\n", wildcards.sampleID, "will be trimmed to a length of 105 reads\n")
                shell("/scratch/c.c1477909/bbmap/bbduk.sh in1={input.r1} in2={input.r2} out1={output.r1} out2={output.r2} ftr={params.edin} ordered=t 2> {log}")

               
rule remove_short_reads:
    input:   r1 = SCRATCH + "/07HARDTRIM_fqs/{sampleID}_val_1.fq.gz",
             r2 = SCRATCH + "/07HARDTRIM_fqs/{sampleID}_val_2.fq.gz"
    output:  r1 = SCRATCH + "/07HARDTRIM_fqs/{sampleID}_val_1.noSR.fq.gz",
             r2 = SCRATCH + "/07HARDTRIM_fqs/{sampleID}_val_2.noSR.fq.gz"
    log:     SCRATCH +  "/00logs/07HARDTRIM_fqs/{sampleID}.noSR.log"
    params:  crdf = 55, extr = 80, edin = 105
    message: "Removing short reads for {wildcards.sampleID}"
    run:
             if "Crdf" in wildcards.sampleID:

                 print("\nReads shorter than 55bps will be removed from: ", wildcards.sampleID, "\n")
                 shell("/scratch/c.c1477909/bbmap/reformat.sh in1={input.r1} in2={input.r2} out1={output.r1} out2={output.r2} minlength={params.crdf} 2> {log}")
             
             elif "Extr" in wildcards.sampleID:
                 
                 print("\nReads shorter than 80bps will be removed from: ", wildcards.sampleID, "\n")
                 shell("/scratch/c.c1477909/bbmap/reformat.sh in1={input.r1} in2={input.r2} out1={output.r1} out2={output.r2} minlength={params.extr} 2> {log}")
            
             else:

                 print("\nReads shorter than 105bps will be removed from: ", wildcards.sampleID, "\n")
       	       	 shell("/scratch/c.c1477909/bbmap/reformat.sh in1={input.r1} in2={input.r2} out1={output.r1} out2={output.r2} minlength={params.edin} 2> {log}")
                 
            

rule read_length_dist_post_QandADtrim:
    input:   trm_r1 = SCRATCH + "/03trim_fstq/{sample}_val_1.fq.gz",
             trm_r2 = SCRATCH + "/03trim_fstq/{sample}_val_2.fq.gz",

    output:  trm_r1 = SCRATCH + "/07read_distribution/trimmed/{sample}_R1_readDist.txt",
             trm_r2 = SCRATCH + "/07read_distribution/trimmed/{sample}_R2_readDist.txt",

    log:     trm = SCRATCH +  "/00logs/read_dist/trimmed/{sample}.log",

    message: "Extracting read distribution for {wildcards.sample}"

    shell:
             """
             printf "\n--------------------------\nExtracting read dist for: {wildcards.sample}_R1\n--------------------------\n\n" 2> {log.trm}
             gunzip -c {input.trm_r1} | awk 'NR%4==2{{print length($0)}}' | sort | uniq -c | sort -nr > {output.trm_r1} 2> {log.trm}
             echo "\n--------------------------\nExtracting read dist for: {wildcards.sample}_R2\n--------------------------\n\n" 2> {log.trm}
             gunzip -c {input.trm_r2} | awk 'NR%4==2{{print length($0)}}' | sort | uniq -c | sort -nr > {output.trm_r2} 2> {log.trm}
             """

rule get_read_length_dist_post_hrdandSR_trim:
    input:   hrd_trm_r1 = SCRATCH + "/07HARDTRIM_fqs/{sampleID}_val_1.fq.gz",
             hrd_trm_r2 = SCRATCH + "/07HARDTRIM_fqs/{sampleID}_val_2.fq.gz",
             hrd_trm_noSR_r1 = SCRATCH + "/07HARDTRIM_fqs/{sampleID}_val_1.noSR.fq.gz",
             hrd_trm_noSR_r2 = SCRATCH + "/07HARDTRIM_fqs/{sampleID}_val_2.noSR.fq.gz"

    output:  hrd_trm_r1 = SCRATCH + "/08READ_DIST/hrd_trm/{sampleID}_R1_readDist.txt",
             hrd_trm_r2 = SCRATCH + "/08READ_DIST/hrd_trm/{sampleID}_R2_readDist.txt",
             hrd_trm_noSR_r1 = SCRATCH + "/08READ_DIST/hrd_trm_noSR/{sampleID}_R1_readDist.txt",
             hrd_trm_noSR_r2 = SCRATCH + "/08READ_DIST/hrd_trm_noSR/{sampleID}_R2_readDist.txt",

    log:     hrd_trm = SCRATCH +  "/00logs/read_dist/hrd_trm/{sampleID}.log",
             hrd_trm_noSR = SCRATCH +  "/00log/read_dist/hrd_trm_noSR/{sampleID}.log"
              
    message: "Extracting read distribution for {wildcards.sampleID}"
   
    run:
             print("\n--------------------------\nExtracting read dist for: {wildcards.sampleID}_R1\n--------------------------\n\n")
             shell("gunzip -c {input.hrd_trm_r1} | awk 'NR%4==2{{print length($0)}}' | sort | uniq -c | sort -nr > {output.hrd_trm_r1} 2> {log.hrd_trm}")

             print("\n--------------------------\nExtracting read dist for: {wildcards.sampleID}_R2\n--------------------------\n\n")
             shell("gunzip -c {input.hrd_trm_r2} | awk 'NR%4==2{{print length($0)}}' | sort | uniq -c | sort -nr > {output.hrd_trm_r2} 2> {log.hrd_trm}")

             print("\n--------------------------\nExtracting read dist for: {wildcards.sampleID}_R1\n--------------------------\n\n")
             shell("gunzip -c {input.hrd_trm_noSR_r1} | awk 'NR%4==2{{print length($0)}}' | sort | uniq -c | sort -nr > {output.hrd_trm_noSR_r1} 2> {log.hrd_trm_noSR}")

             print("\n--------------------------\nExtracting read dist for: {wildcards.sampleID}_R2\n--------------------------\n\n")
             shell("gunzip -c {input.hrd_trm_noSR_r2} | awk 'NR%4==2{{print length($0)}}' | sort | uniq -c | sort -nr > {output.hrd_trm_noSR_r2} 2> {log.hrd_trm_noSR}")
             

rule ase_align:
    input:   genotype = SCRATCH + "/05vcfs/{sampleID}.chr.vcf",
             index = SCRATCH + "/04static_index/",
             r1 = SCRATCH + "/07HARDTRIM_fqs/{sampleID}_val_1.noSR.fq.gz",
             r2 = SCRATCH + "/07HARDTRIM_fqs/{sampleID}_val_2.noSR.fq.gz"
    
    output:  SCRATCH + "/09ASE_MAPPINGS/{sampleID}.ase.txt"
    
    log:     SCRATCH + "/00logs/09ASE_MAPPINGS/{sampleID}.ase.log"
    
    params:  jobname = "{sampleID}", crdf = 55, extr = 80, edin = 105,
             index = SCRATCH + "/04static_index/ASElux_static_index"
    
    message: "Calculating allele specific expression for sample {wildcards.sampleID}"
    
    run: 
             if "Crdf" in wildcards.sampleID:

                 print("\nRunning ASE for: ", wildcards.sampleID, "\n")
                           
                 shell("""
                 
                 module load compiler/gnu/5
                 PREFIX_r1=$(echo "{input.r1}" | cut -f 1-4 -d '.')
                 PREFIX_r2=$(echo "{input.r2}" | cut -f 1-4 -d '.')
       	     
       	         gunzip -c {input.r1} > ${{PREFIX_r1}}
       	         gunzip -c {input.r2} > ${{PREFIX_r2}}
                 ASElux align --fq --pe --readLen {params.crdf} --index {params.index} \
                 --vcf {input.genotype} --seqFiles ${{PREFIX_r1}} ${{PREFIX_r2}} \
                 --out {output} 2> {log}
                 rm ${{PREFIX_r1}}
                 rm ${{PREFIX_r2}} 
                 
                 """)

             elif "Extr" in wildcards.sampleID:

                 print("\nRunning ASE for: ", wildcards.sampleID, "\n")

                 shell("""
                 module load compiler/gnu/5
                 PREFIX_r1=$(echo '{input.r1}' | cut -f 1-4 -d '.')
                 PREFIX_r2=$(echo '{input.r2}' | cut -f 1-4 -d '.')
                 gunzip -c {input.r1} > ${{PREFIX_r1}}
                 gunzip -c {input.r2} > ${{PREFIX_r2}}
                 ASElux align --fq --pe --readLen {params.extr} --index {params.index} \
                 --vcf {input.genotype} --seqFiles ${{PREFIX_r1}} ${{PREFIX_r2}} \
                 --out {output} 2> {log}
                 rm ${{PREFIX_r1}} 
                 rm ${{PREFIX_r2}} 
       	         
                 """)

             else:

                 print("\nRunning ASE for: ", wildcards.sampleID, "\n")

                 shell("""
                 module load compiler/gnu/5
                 PREFIX_r1=$(echo '{input.r1}' | cut -f 1-4 -d '.')
                 PREFIX_r2=$(echo '{input.r2}' | cut -f 1-4 -d '.')
                 gunzip -c {input.r1} > ${{PREFIX_r1}}
                 gunzip -c {input.r2} > ${{PREFIX_r2}}
                 ASElux align --fq --pe --readLen {params.edin} --index {params.index} \
                 --vcf {input.genotype} --seqFiles ${{PREFIX_r1}} ${{PREFIX_r2}} \
                 --out {output} 2> {log}
                 rm ${{PREFIX_r1}}
                 rm ${{PREFIX_r2}}
                  
                 """)
                  

             

###############################################################################
###############################################################################
